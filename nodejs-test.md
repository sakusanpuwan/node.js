## Jest

`npm install jest` - Installs the Jest testing framework as a dependency in the package.json file.

`jest` - A JavaScript testing framework that allows developers to write and run tests for their code. It provides features such as test runners, assertions, and mocking.

```json
{
  "scripts": {
    "test": "jest", // Runs all tests in the project
    "test:watch": "jest --watch", // Runs tests in watch mode, re-running tests when files change
    "test:coverage": "jest --coverage", // Generates test coverage reports
    "test:verbose": "jest --verbose" // Runs tests with detailed output
  }
}
```

`npm install babel-jest @babel/core @babel/preset-env` - Installs Babel and its preset for transforming modern JavaScript code into a version compatible with older environments.
`babel-jest` - A Jest transformer that allows Jest to process JavaScript files using Babel.

`@babel/core` - The core library of Babel, which is responsible for transforming JavaScript code.

`@babel/preset-env` - A preset that allows you to use the latest JavaScript features by automatically determining the Babel plugins and polyfills needed based on your target environment.

```
// .babelrc
{
  "presets": ["@babel/preset-env"]
}
```

`npm run test:coverage` - Runs Jest with coverage reporting enabled, generating a coverage report for the tests.

`npm run test <test_name>` - Runs a specific test file or test case by name.

To run run myFunction.test.js, use the following command: `npm run test myFunction`

`./coverage/lcov-report/index.html` - The coverage report generated by Jest, which can be opened in a web browser to view detailed coverage information.

### `describe` block

Groups related tests for a function/module.

```js
describe("myFunction", () => {
  test("does something", () => {
    // your test here
  });
});
```

### `beforeEach` block

Runs a function before each test in the `describe` block.

```js
beforeEach(() => {
  // setup code here
});
```

### `test()` or `it` block

```js
test("adds 1 + 2 to equal 3", () => {
  expect(1 + 2).toBe(3);
});
```

### `expect()` function

The `expect` function is used to create an assertion in Jest tests. It takes a value as an argument and returns an object with various matchers that can be used to assert conditions about that value.

```js
expect(value).toBe(expectedValue); // Checks if value is equal to expectedValue
```

| Matcher                          | Purpose                          |
| -------------------------------- | -------------------------------- |
| `toBe(value)`                    | Checks strict equality (`===`)   |
| `toEqual(obj)`                   | Deep equality for objects/arrays |
| `toBeTruthy()` / `toBeFalsy()`   | Checks truthiness                |
| `toBeNull()` / `toBeUndefined()` | Null / undefined checks          |
| `toContain(item)`                | Array/string contains            |
| `toThrow(error?)`                | Function throws error            |
| `resolves.toEqual()`             | Async success result             |
| `rejects.toThrow()`              | Async error thrown               |
| `.not` matcher                   | Negates the assertion            |

### Stubbing

Stubbing is a technique used in testing to replace a function or method with a controlled fake implementation. It allows you to control the behavior of the function being tested and isolate it from its dependencies.

Used when you want to prevent a function from executing its original implementation and instead return a predefined value or behavior.

```js
import db from "./db.js";

jest.mock("./db.js", () => ({
  save: jest.fn().mockResolvedValue("OK"),
}));
```

### Mocking

Mocking is a technique used in testing to create fake implementations of functions or objects and verify it was called with expected arguments. It allows you to isolate the code being tested and control its behavior.

Used when you want to test how a dependency interacts with the code being tested without actually executing the dependency's implementation.

```js
const mockFunction = jest.fn(); // Creates a mock function
mockFunction.mockReturnValue("mocked value"); // Sets the return value of the mock function
mockFunction("arg1", "arg2"); // Calls the mock function with arguments
expect(mockFunction).toHaveBeenCalledWith("arg1", "arg2"); // Asserts that the mock function was called with specific arguments
expect(mockFunction).toHaveBeenCalledTimes(1); // Asserts that the mock function was called once
```

`mockFunction.mock.calls` - Returns an array of all calls made to the mock function, including the arguments passed to each call.

### Spying

Spying is a technique used to monitor the behavior of functions or methods without modifying their implementation. It allows you to track how many times a function was called, what arguments were passed, and what values were returned.

```js
import * as math from "./math.js";

jest.spyOn(math, "add");
math.add(2, 3);
expect(math.add).toHaveBeenCalledWith(2, 3);
expect(math.add).toHaveBeenCalledTimes(1); // Asserts that the add function was called once
```

| Tool                      | Purpose                             |
| ------------------------- | ----------------------------------- |
| `jest.fn()`               | Create mock function                |
| `jest.spyOn()`            | Wrap real method to mock/observe    |
| `.mockReturnValue()`      | Mock sync return                    |
| `.mockResolvedValue()`    | Mock async resolved value (Promise) |
| `.mockImplementation()`   | Provide custom logic                |
| `.toHaveBeenCalledWith()` | Assert call with specific arguments |

### `jest.fn()`

Creates a **standalone mock function**.

```js
const mockFunc = jest.fn();
mockFunc("test");
console.log(mockFunc.mock.calls); // [ ['test'] ]
```

With custom implementation:

```js
const add = jest.fn((a, b) => a + b);
add(2, 3); // 5
```

---

### `jest.spyOn(object, method)`

Spies on an **existing method** â€” can observe or override it.

```js
const user = {
  greet: (name) => `Hello, ${name}`,
};

const spy = jest.spyOn(user, "greet");
user.greet("John");

expect(spy).toHaveBeenCalledWith("John");
```

With mock:

```js
jest.spyOn(user, "greet").mockImplementation((name) => `Hi, ${name}`);
```

---

### `.mockReturnValue(value)`

Sets a **sync return value** for a mock function.

```js
const getName = jest.fn().mockReturnValue("Alice");
console.log(getName()); // 'Alice'
```

---

### `.mockResolvedValue(value)`

Sets a **resolved value** for an async mock (returns a Promise).

```js
const fetchData = jest.fn().mockResolvedValue({ id: 1 });

await expect(fetchData()).resolves.toEqual({ id: 1 });
```

---

### `.mockImplementation(fn)`

Provides a **custom implementation** for a mock.

```js
const multiply = jest.fn().mockImplementation((a, b) => a * b);
multiply(2, 3); // 6
```

---

### `.toHaveBeenCalledWith(...)`

Verifies a function was called with specific arguments.

```js
const greet = jest.fn();
greet("Alice");

expect(greet).toHaveBeenCalledWith("Alice");
```

---

### Full Example

### Code (`myModule.js`)

```js
export const utils = {
  add: (a, b) => a + b,
};

export function process(x, y, callback) {
  const result = utils.add(x, y);
  callback(result);
  return result;
}
```

### Test (`myModule.test.js`)

```js
import { utils, process } from "./myModule.js";

test("process uses add and calls callback with result", () => {
  const spy = jest.spyOn(utils, "add").mockReturnValue(10); // spy + stub
  const cb = jest.fn(); // stub

  const result = process(3, 7, cb);

  expect(spy).toHaveBeenCalledWith(3, 7); // verify spy
  expect(cb).toHaveBeenCalledWith(10); // verify stub
  expect(result).toBe(10);
});
```
